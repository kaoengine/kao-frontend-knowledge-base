# CSS Layout Practice

Front-end development is like building a house. If HTML is the brick that makes up a house, CSS determines the location of these bricks and decorates them. In actual development, after the front-end engineers get the design draft, they will sort out the general structure of the page first, and then carry out coding after conceiving the layout of the page. Most websites have similar layouts. Mastering these "routines" can quickly and efficiently complete the development work.

## Related Attributes

## Display

Display is an important attribute in CSS layout. It defines the type of display box generated by elements. Several common attribute values are: **_`block`_** ,
**_`inline`_** , **_`inline-block`_** , **_`inherit`_**,**_`none`_** , **_`flex`_** . inherit indicates that the element inherits the display attribute value from the parent element; none indicates that the element does not display or occupy space; flex is [flex layout](/FlexLayout.md) For important attribute settings, we will explain them in detail later. Here we will introduce the first three attribute values.

Each element has a default display attribute. For example, the default display attribute of a **div tag** is block. We usually call this type of element `Block-level elements` ; The default display attribute of **span tags** is inline, which we usually call `Inline elements` , let's take the following code example to see the difference between the two.

```html
<div class="element">div 1</div>
<div class="element">div 2</div>
<div class="element">div 3</div>
<div class="element">div 4</div>
```

```html
<span class="element">span 1</span>
<span class="element">span 2</span>
<span class="element">span 3</span>
<span class="element">span 4</span>
```

```CSS
.element {
    width: 100px;
    height: 100px;
    text-align: center;
    background-color: #FFB5BF;
    padding: 10px;
    margin: 10px;
}
```

The running effects of the two are as follows:

![Alt text](/images/block.png)

<p align="center">Block Level Elements</p>

![Alt text](/images/inline.png)

<p align="center">In-line Elements</p>

We can see that block-level elements always occupy a row exclusively, from top to bottom, while elements in the row are displayed from left to right. This is because block-level elements have line breaks before and after, while elements in lines have no line breaks before and after. In addition, block-level elements and in-line elements have other differences and characteristics.

#### Block-level elements:

- When no width is set, its width is 100% of its container.

- You can set box model attributes such as width and height, inner margin, and outer margin for block-level elements.

- Block-level elements can contain block-level elements and In-line elements.

- Common block-level elements are: `<div>`, `<h1> ~ <h6>` , `<p>`, `<ul>` , `<ol>`, `<dl>` , `<table>` ,`<address>`, `<form>`.

#### In-line elements:

- The elements in the row do not occupy a row exclusively, but only occupy the space required by its own width and height.

- Setting the width and height of the elements in the row does not work, **_the margin value only works for the left and right, and the padding value only works for the left and right_**.

- **_In-line elements generally cannot contain block-level elements, but can only contain in-line elements and text_**.

- Common in-line elements are `<a>` , `<b>`, `<label>` , `<span>` , `<img>` , `<em>` , `<strong>` , `<i>` , `<input>`.

#### Note:

Careful you may find that setting the width and height of img tags can affect the image size, because img is [Alternative elements](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element) , **alternative elements have internal dimensions, so the width and height can be set. `input`, `button`, `textarea`, and `select` in HTML are all alternative elements**. Even if these elements are empty, the browser will decide the displayed content according to their tags and attributes.

#### Important

> Setting width and height for elements in the `In-line Elements` does not work. We have already felt through the above code that why setting margin only works left and right? Let's take a look at the following columns.

```html
<div>div 1</div>
<span>span 1</span>
<span>span 2</span>
<div>div 2</div>
```

```CSS
div {
    width: 100px;
    height: 100px;
    text-align: center;
    background-color: #94E8FF;
}
span {
    width: 100px; /* does not work*/
    height: 100px; /* does not work*/
    background-color: #FFB5BF;
    padding: 10px; /* padding-top , padding-bottom seem to work, but be carefuly, pls read the explanation below*/
    margin: 10px; /* does not work with margin-bottom and margin-top */
}
```

![Alt text](/images/blockInline.png)

<p align="center">(Add the running result of div tag in browser before and after span tag)</p>

It is obvious that only `margin-left` and `margin-right` are added to **span 1** in the above figure, but `margin-top and margin-bottom` **do not work**. Although **`padding-top`** and **`padding-bottom`** seem to work, by adding div tags, we can see overlapping parts, so **padding-top**, the **padding-bottom** setting is increased from the display effect, but does not affect the surrounding elements.

#### inline-block

Elements are set to `inline-block` not only have the feature that `block-level` elements can be set to **width and height**, but also have the feature that elements in `rows do not wrap lines`. Let's set the **inline-block** property for the div tag to see the effect.

```html
<div class="reset">div 1</div>
<div class="reset">div 2</div>
<div class="reset">div 3</div>
<div class="reset">div 4</div>
```

```CSS
.reset {
    width: 100px;
    height: 100px;
    text-align: center;
    background-color: #FFB5BF;
    display: inline-block;
}
```

![Alt text](/images/inline-block.png)

<p align="center">(The effect after the display attribute of the block-level element is set to inline-block)</p>

In the above figure, we did not set the margin value, but `there is a gap between div`, because the browser will **merge line breaks, tabs, and white spaces in HTML into white spaces**. For how to eliminate the middle gap, it is recommended to read [N methods to remove spacing between inline-block elements](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/).

## Position

Positioning is a very important factor in layout, and the position attribute is used to define the positioning mechanism of elements. The common attribute values of position are:

- relative: relative positioning, relative to the normal position of the element.

- absolute: absolute positioning, positioning relative to elements other than static positioning.

- fixed: fixed positioning. Compared with the browser window, the fixed header and footer in the website are implemented by fixed positioning.

- static: default value, no location attribute, elements normally appear in the document stream.

- inherit: inherits the position attribute value of the parent element.

> The concept of "normal flow" appears above, which should be translated into "normal flow" by rights. Document flow is called by most people. "Flow" can be imagined as flowing water. When we open the screen, browse the web page and scroll the mouse, the content of the web page will slide through like water flow. Document flow refers to the document layout from top to bottom and from left to right. **When we set the positon attribute of an element to `absolute` and `fixed`, it will break away from the document flow and no longer follow the rules from top to bottom and from left to right**.

1. Relative example:

```html
<div class="common box_1">box 1</div>
<div class="common box_2">box 2</div>
<div class="common box_3">box 3</div>
```

```CSS
.common {
    width: 100px;
    height: 100px;
    text-align: center;
}
.box_1 {
    position: relative;
    background-color: #FFB5BF;
}
.box_2 {
    position: relative;
    background-color: #94E8FF;
    left: 10px;
    top: 10px;
}
.box_3 {
    background-color: #8990D5;
}
```

![Alt text](/images/relative.png)

<p align="center">Example where position is relative</p>

From the above figure, it is not difficult to find that setting position to relative without adding additional attributes (left,right,top,bottom, etc.) **is the same as static**, such as. `box_1.`Attributes **left, right, top, and bottom** make the element **deviate** from the normal position, such as. `box_2`. The offset of an element overwrites adjacent elements, such as. `box_3`.

2. absolute example

```html
<div class="relative">
  relative
  <div class="absolute">absolute</div>
</div>
```

```CSS
.relative {
    width: 200px;
    height: 200px;
    border: 2px solid #FFB5BF;
    position: relative;
}
.absolute {
    width: 100px;
    height: 100px;
    border: 2px solid #94E8FF;
    position: absolute;
    bottom: 10px;
    right: 10px;
}
```

![Alt text](/images/absolute.png)

<p align="center">Example where position is absolute</p>

**absolute locates relative to the nearest element other than static positioning**. When using it, pay attention to setting the position attribute of the parent element (or ancestor element), if the parent element (or ancestor element) no positioning attribute is set, absolute will find the top layer, namely the browser window, positioning relative to it.

3. fixed example

```html
<div class="fixed"></div>
<span
  >The p tag defines a paragraph. Browsers automatically add some space (margin)
  before and after each p element...</span
>
...
<span
  >The p tag defines a paragraph. Browsers automatically add some space (margin)
  before and after each p element...</span
>
```

```CSS
.fixed {
    width: 100px;
    height: 100px;
    background-color: #FFB5BF;
    position: fixed;
    left: 20px;
    top: 20px;
}
```

![Alt text](/images/fix.gif)

<p align="center">Example of fixed position</p>

**fixed is the position relative to the browser window**. Once the position is determined, the position of the element will not change. Unlike absolute, its position is closely related to the parent element, and it will also move when the parent element moves. As can be seen from the above figure, the fixed element is separated from the document flow, and the following elements will "ignore" it and will not make room for it.

## float

The float attribute defines the direction in which the element floats. Common attribute values include `left` , `right` , that is, **floating left and right**. The float element is separated from the document stream and then moved left or right until it touches the boundary of the parent container or another floating element. **Block-level elements ignore the float element, while text and line elements surround it. Therefore, float is initially used to achieve the text surround effect**.

```html
<div class="container">
  <div class="box_1">box 1</div>
  <div class="box_2">
    The young applicant is described as confident and courageous. His résumé, at
    15 pages, is glittering, ...
  </div>
</div>
```

```CSS
.container {
    width: 100%;
    height: 150px;
    background-color: #94E8FF;
}
.box_1 {
    width: 100px;
    height: 100px;
    text-align: center;
    background-color: #FFB5BF;
    float: left;
}
```

![Alt text](/images/float1.png)

<p align="center">Text surround effect</p>

We know that when the width and height of the parent element are not set, the width and height of the parent element will expand the content of the quilt element. However, when the child element sets the floating attribute, the child element will overflow outside the parent element, and the width and height of the parent element will not be opened, which is called "height collapse", let's experience this difference through code.

```html
<div class="container">
  <div class="box_1 float">box 1</div>
  <div class="box_2 float">box 2</div>
</div>
```

```CSS
.container {
    border: 3px solid #8990D5;
}
.box_1 {
    height: 100px;
    width: 100px;
    text-align: center;
    background-color: #FFB5BF;
}
.box_2 {
    height: 100px;
    width: 100px;
    text-align: center;
    background-color: #94E8FF;
}
.float {
    float: left;
}
```

![Alt text](/images/float2.png)

<p align="center">Floating child elements cannot support parent elements</p>

How to solve this problem? To solve this problem is **Clear float** , below we give several conventional solutions.

1. **_Clear the float with the clear attribute by adding additional tags._**

The clear attribute is used to define which side does not allow other elements to float. Common values are left , right , both , indicating that elements are not allowed to float on the left, elements are not allowed to float on the right, and elements are not allowed to float on the left and right sides.

```html
<div class="container">
  <div class="box_1 float">box 1</div>
  <div class="box_2 float">box 2</div>
  <div class="clear"></div>
</div>
```

```CSS
.clear {
    clear: both;
}
```

![Alt text](/images/float3.png)

<p align="center">Use clear: both to open the parent element</p>

2. **_Use br labels_**

`br` has its own clear attribute. The clear attribute has three attribute values: **left, right, and all**.

```html
<div class="container">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
    <br clear="all"></br>
</div>
```

This method is the same as adding empty tags in the previous method, and also achieves the purpose of clearing floating. Compared with the previous method, the semantics is more obvious, but there is also the problem of separating structure, style and behavior, **not recommended**.

3. **_Set overflow for the parent element_**

```html
<div class="container overflow">
  <div class="box_1 float">box 1</div>
  <div class="box_2 float">box 2</div>
</div>
```

```CSS
.overflow {
    overflow: hidden;
    zoom: 1;   /* Compatible IE6、IE7 */
}
```

Adding overflow not only reduces the amount of code, but also does not have semantic problems. However, excessive content may be hidden due to increased content. The first two methods have the clear keyword, which is very easy to understand, but only set `overflow: hidden`; Why can float be cleared?

Here is a concept to be introduced: [BFC](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context), Block-level Formatting Context. One feature of BFC is that it can contain floating elements. Setting overflow to hidden satisfies the condition of creating a BFC. In fact, it is to create a BFC and use the inherent characteristics of BFC to clear the floating elements. This is not to be explained too much, interested partners can consult relevant information.

4. **_Using after pseudo elements_** it is considered the best trick to handle clearing float for me

```html
<div class="container">
  <div class="box_1 float">box 1</div>
  <div class="box_2 float">box 2</div>
</div>
```

```CSS
.container::after {
    content: '';
    clear: both;
    display: block;
    height: 0;
    visibility: hidden;
}
.container {
    border: 3px solid #ccc;
    zoom: 1;   /* Compatible IE6、IE7 */
}
```

The essence of this method is to add an invisible block element at the end to clear the float. There is no semantic problem with this method, and it is the current mainstream method to eliminate floating.

## Classic Layout Example

After learning the above attributes related to the layout, we will apply them to the actual scenario. In many web pages, for symmetry and beauty, most pages are divided into several parts, such as header, footer, navs, core content section, etc. The following two figures show the fixed width on the left, the self-adaptive layout of two columns on the right and the width on both sides on the left, and the self-adaptive layout of three columns in the middle. Let's see how it is implemented.

![Alt text](/images/twoColumn.png)

<p align="center">Taobao web version Account Management page screenshot-two-column layout</p>

![Alt text](/images/threeColumn.png)

<p align="center">SegmentFault web page screenshot-three-column layout</p>

#### Two-column layout

The layout of the two columns is relatively simple, and the general effect is as follows:

![Alt text](/images/twoColumn2.png)

<p align="center">Two-column layout renderings</p>

Let's first give the basic part of the code:

```html
<div class="container">
  <div class="left">left</div>
  <div class="right">right</div>
</div>
```

```CSS
.left {
    width: 100px;
    height: 150px;
    background-color: #FFB5BF;
}
.right {
    height: 150px;
    background-color: #94E8FF;
}
```

At this time,**.left** and **.right** must have their own exclusive lines, which we have explained above. But looking at our final rendering, two div elements are in one line, how to implement it? We can implement it in combination with the relevant attributes learned above.

1. Set display to inline-block

`inline-block` has the feature that you can set the width and height of block-level elements and the elements in the row do not occupy one row exclusively. If you set the two div of `inline-block`, there will be space between them. Remember to eliminate them. Since the left side is fixed and the total width is 100%, to calculate the width on the right side, you can use [calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc) To calculate.

```CSS
.container {
    font-size: 0;    /* Eliminate the space */
}
.left, .right {
    display: inline-block;
}
.right {
    width: calc(100% - 100px);   /* Calculate the width, there must be spaces around the left and right */
}
```

2. Use float

float is varied. The following three methods are given to achieve the layout of the two columns in the above figure by using the characteristics of float.

We know that `block-level elements` in the document stream cannot perceive the existence of floating elements, if **set **.left** is left floating, so will the **.right\*\*\*\*.

The left element does not exist because the default width of the `block-level element` is 100% of the parent element. At the time, The width of the right is already 100%, and there is no need to calculate. Don't forget to set the margin value of **.right** to reserve space for **.left** to make the two look harmonious. This is the first method. The code is as follows:

```CSS
.left {
    float: left;
}
.right {
    margin-left: 100px;   /* Leave space for .left */
}
.container {
    overflow: hidden;    /* don't forget to clear the float */
}
```

The floating element is separated from the document stream until it touches the border of the parent element or another floating element, so we can also set it **.left**, Both **right and left float**, then they will be arranged in a row closely. Because **.right** is floating, the width needs to be calculated. This is the second method:

```CSS
.left {
    float: left;
}
.right {
    float: left;
    width: calc(100% - 100px);
}
.container {
    overflow: hidden;
}
```

When the left floats, **.right** will ignore **.left**, is there any possibility of not ignoring and leaving a position? Yes, let **.right** form `BFC (block formatting context)`, **.right** will not coincide with **.left**. BFC will not ignore floating elements, which is also one of its characteristics. This is the third method:

```CSS
.left {
    float: left;
}
.right {
    overflow: auto;    /* Form BFC */
}
.container {
    overflow: hidden;
}
```

3. Use absolute

Set the position of **.left** to absolute, **.left** is separated from the document flow, **.right** ignores the existence of **.left**.

```CSS
.container {
    position: relative;
}
.left {
    position: absolute;
}
.right {
    margin-left: 100px;
}
```

#### Three-column layout

The layout of the three columns is familiar with the layout of the Holy Grail and the layout of the flying wings. The layout of the Holy Grail comes from an article in 2006: [In Search of the Holy Grail](https://alistapart.com/article/holygrail/) . The layout of shuangfeiyi started from Taobao. Both of them are solving the three-column layout with fixed width on both sides and self-adaption in the middle, and the main content should be rendered preferentially. According to the loading principle of DOM from top to bottom, the self-adaption part in the middle should be placed in the front.

1. Holy Grail layout

First, we build the basic framework of the layout. In the following code, the parent div contains three sub-divs. We write. center in the front to facilitate rendering first. To ensure that the window can still be displayed when it shrinks, we set the minimum width for the body.

```html
<div class="container">
  <div class="center"></div>
  <div class="left"></div>
  <div class="right"></div>
</div>
```

```CSS
body {
    min-width: 630px;
}
.center {
    width: 100%;
    height: 150px;
    background-color: #94E8FF;
}
.left {
    width: 100px;
    height: 150px;
    background-color: #FFB5BF;
}
.right {
    width: 200px;
    height: 150px;
    background-color: #8990D5;
}
```

Refresh the browser, the effect is as follows:

![Alt text](/images/threeColumn2.png)

<p align="center">(Basic framework renderings)</p>

As expected, each of the three sub-divs occupies one line and shows it. At this time, we add left float to all three to see the effect.

```CSS
.container {
    overflow: hidden;   /* clear floating */
}
.center, .left, .right {
    float: left;
}
```

![Alt text](/images/threeColumn3.png)

<p align="center">(Set the effect after left floating)</p>

Because **.center** sets 100% width, so **.left** and **.right** side was squeezed to the bottom. At this time, the problem we need to solve is how to make it double up, which requires the negative value of margin. We know `margin-left: 10px`; Is to set the left outer margin of 10px, left should be a little more empty, visual effect is to move to the right of 10px, then if `margin-left: -10px`;? The left outer spacing should be reduced by 10px, which naturally moves to the left by 10px.

Let's go back to the problem to be solved. Because the width of **.center** is 100%, **.left** and **.right** are in the second row, which can be understood as behind **.center**. At this time, **.left** has to return the leftmost part of **.center** is to move to the left. After the left is moved, **.right** will be automatically added the vacancy of **.left** , at this time, **.right** want to achieve the rightmost part of the center, just move its own width to the left, which is, 200px.

```CSS
.left {
    margin-left: -100%;
}
.right {
    margin-left: -200px;
}
```

![Alt text](/images/threeColumn4.png)

<p align="center">(Move the left and right elements up by using margin-left)</p>

At this time, it seems that the layout of the Holy Grail has been realized. **Looking carefully**, I found that The text _center_ is blocked, at this time **.left**, **.right** are covered in. On the top of the center, we need to leave a place for both.

The way to layout the holy grail is to set the parent element first. The padding property of the container **.left**. Leave space on the right, and the space needed by the two is the width of the two, and then use the positioning attribute to make it homing. Let's set padding first to see the effect.

```CSS
.container {
    padding-left: 100px;
    padding-right: 200px;
}
```

![Alt text](/images/threeColumn5.png)

<p align="center">(The parent element sets padding to leave space for the elements on the left and right sides)</p>

Since padding is set for the parent element, all the child elements are squeezed to the middle. At this time, you only need to pull **.left** and **.right** to the prepared empty space respectively. First, set the positioning attribute to `relative`, which is, position relative to itself , **.left** needs to move 100px to the left, **.right** needs to move 200px to the right, So **.left** only needs to be set left: -100px; , **.right** settings right: -200px; The effect can be achieved.

```CSS
.left {
    position: relative;
    left: -100px;
}
.right {
    position: relative;
    right: -200px;
}
```

![Alt text](/images/threeColumn6.png)

<p align="center">(Use relative positioning to place the left and right elements)</p>

Here, the layout of the Holy Grail is completed. Its core idea is to use floating layout and padding to leave space for left and right elements, flexible use of negative values and relative positioning of margin to move elements to corresponding positions. The complete code is as follows:

```html
<div class="container">
  <div class="center">center</div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
```

```CSS
body {
    min-width: 630px;
}
.container {
    overflow: hidden;
    padding-left: 100px;
    padding-right: 200px;
}
.center {
    width: 100%;
    height: 150px;
    background-color: #94E8FF;
    float: left;
}
.left {
    width: 100px;
    height: 150px;
    background-color: #FFB5BF;
    float: left;
    margin-left: -100%;
    position: relative;
    left: -100px;
}
.right {
    width: 200px;
    height: 150px;
    background-color: #8990D5;
    float: left;
    margin-left: -200px;
    position: relative;
    right: -200px;
}
```

2. Double Flying wing layout

The layout of double wings is the same as the front part of the Holy Grail layout, and there are differences in the thinking of leaving positions for the left and right elements. The Holy Grail layout is to set the padding of the parent element to leave space, and then use the relative to return. In the double Fei Yi, an extra div is added to wrap the self-adaptive part in the middle, and the margin of the sub-div is used to leave space for the left and right elements.

```html
<div class="container">
  <div class="center-container">
    <div class="center">center</div>
  </div>
  <div class="left">left</div>
  <div class="right">left</div>
</div>
```

```CSS
body {
    min-width: 630px;
}
.container {
    overflow: hidden;
}
.center-container {
    width: 100%;
    float: left;
}
.center-container .center {
    height: 150px;
    background-color: #94E8FF;

    margin-left: 100px;        /* newly added attribute */
    margin-right: 200px;       /* newly added attribute */
}
.left {
    width: 100px;
    height: 150px;
    background-color: #FFB5BF;
    float: left;
    margin-left: -100%;
}
.right {
    width: 200px;
    height: 150px;
    background-color: #8990D5;
    float: left;
    margin-left: -200px;
}
```

![Alt text](/images/threeColumn7.png)

<p align="center">(The layout rendering of double flying wings is exactly the same as the layout of Holy Cup)</p>

The same problem is that the layout of the twin wings is realized by adding a div and using margin, while the layout of the Holy Grail is realized by padding, relative positioning and setting offset (left and right), relatively speaking, the layout of twin wings is easier to understand. In the layout of the Holy Grail, the screen is infinitely reduced (assuming that the minimum width of the body is not set). When the width of .main is less than **.left**, layout disorder will occur.

#### Summary

This section mainly introduces several important attributes and related attribute values in CSS layout. Different attribute values have different effects on the layout. After that, several implementation methods of the layout of the two columns are introduced, and two typical layout of the three columns, the famous Holy Grail layout and the double flying wing layout, are introduced in detail. There are various CSS layouts. If you use a float, you need to clear the float. It may also cause uncontrollable layout disorder. Read the following [flex layout](/FlexLayout.md), you may have a better solution to the layout of two columns and three columns. All Roads Lead to Rome. In this section, you need to master:

- Use of display, position, float and other attributes.

- How to clear the float.

- Use the above attributes to flexibly complete the layout of two columns.

- The concrete realization of the layout of the Holy Grail.

- Double Flying wing layout and the Holy Grail layout differences and quality.

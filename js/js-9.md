JS (Nine) scope, scope chain
=================

## Scope refinement
* [[scope]]: Each JavaScript function is an object. Some attributes object we can access, but some do not, these attributes provide only JavaScript engine access, [[scope]]it is one of them.

* [[scope]]: Refers to what we call a `scope` , which stores a collection of runtime contexts.

* Scope chain: [[scope]] a collection of execution context objects stored in this collection. This collection is a chain link. We call this chain link a scope chain.

* Run-time context: When the function executes, an internal object called the run-time context is created. An execution context defines the environment when a function is executed. The execution context corresponding to each function execution is unique, so multiple calls to a function will result in the creation of multiple execution contexts. Execution context was destroyed.

* Find variables: Look down from the top of the scope chain in sequence.

```js
function  a() {
    function  b() {
        var  b  =  234 ;
    };
    
    var  a  =  123 ;
    
    b();
}

var glob = 100;
a();
```

First let's look at the above function, this is a whole function, a is in the global scope, then there is the variable glob below, and then this a is executed.


The first step: First of all, what the system sees is this definition of a. If the definition of a is this [[scope]]

| a             | / |
|---------------|---|
| \[\[scope\]\] | / |

**scope points to scope chain**

 scope chain                        | scope points here |
|-----------------------------------|-------------------|
| 00 at this position points to GO  | GO                |


| Global Object | 0 points to this table |
|---------------|------------------------|
| this          | window                 |
| window        | \(object\)             |
| document      | \(object\)             |
| a             | \(function\)           |
| globe         | 100                    |


[[scope]] inside execution of global context, a is executed, and the AO generated by a is stored at the top of the scope chain to form a new scope chain Now, the [[scope]] of a is different from that of [[scope]].

| a             | / |
|---------------|---|
| \[\[scope\]\] | / |

scope points to scope chain


| scope chain                           | scope points here |
|---------------------------------------|-------------------|
| 0 0 points to the location of the  AO | AO                |
| 1 0 points to the location of the  GO | GO                |


| Activation  Object | 0 points to this table |
|--------------------|------------------------|
| this               | window                 |
| arguments          | \[\]                   |
| a                  | 123                    |
| b                  | \(function\)           |

| Global Object | 1 points to this table |
|---------------|------------------------|
| this          | window                 |
| window        | \(object\)             |
| document      | \(object\)             |
| a             | \(function\)           |
| globe         | 100                    |


It's just not the same as the value stored inside is not the same [[scope]] or the [[scope]]. At this time, we don't see the below. If we access a variable at this time, we access the [[scope of a ]], It take things from [[scope]] of a, the scope of a is a warehouse, there is a scope chain stored in this library, and various variables are hung in it. Look down .

A is then performed, resulting in b is defined, and a can only be executed. When b is executed, there is a natural [[scope]], [[scope]] stores a scope that it should have chain, but it has a different scope chain than a. When a is defined, it is in the global. The only attributes that can be accessed are its own AO and global GO, but b is in the a function. It is defined in it, so [[scope]] of b can not only access its own AO, but also the AO of a, and the global GO.

| b             | / |
|---------------|---|
| \[\[scope\]\] | / |

scope points to scope chain

| scope chain                            | scope points here  |
|----------------------------------------|--------------------|
| 00 points to the location of their AO  | 0 own AO           |
| 01 points to the location of the a AO  | 1 points to the AO |
| 02 points to the location of the GO    | 2 points to GO     |


| Activation  Object | 0 points to this table |
|--------------------|------------------------|
| this               | window                 |
| arguments          | \[\]                   |
| b                  | 234;                   |

| Activation  Object | 1 points to this table |
|--------------------|------------------------|
| this               | window                 |
| arguments          | \[\]                   |
| a                  | 123                    |
| b                  | \(function\)           |


| Global Object | 2 points to this table |
|---------------|------------------------|
| this          | window                 |
| window        | \(object\)             |
| document      | \(object\)             |
| a             | \(function\)           |
| globe         | 100                    |


### Scope destruction

When b is executed, destroy its own AO and return to the defined state, waiting for the next execution.
Because b is the last sentence of function a, after b is executed, a is also destroyed, so [[scope]] with b is also destroyed, it returns to the defined state, waiting for the next execution.

```js
//example
function  a ( )  {
    function  b ( )  {
        function  c ( ) {
            
        }
        c();
    }
    b();
}
a();    
```

```text
a defined a.[[scope]] --> 0:GO

a doing   a.[[scope]] --> 0:a of AO
                          1:GO
                          
b defined b.[[scope]] --> 0:a of AO
                          1:GO

b  doing    b . [ [ scope ] ] - > 0 : own AO  
                          1 : a  of  AO 
                          2:GO
                          
c defined c.[[scope]] --> 0:a of AO
                          1 : AO of c 
                          2:GO

c  doing    c . [ [ scope ] ] - > 0 : own AO  
                          1 : b's AO
                          2 : a  of  AO
                          3:GO
```

**So the external function cannot access the properties and values of the internal function**